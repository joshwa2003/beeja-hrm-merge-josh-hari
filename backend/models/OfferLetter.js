const mongoose = require('mongoose');
const crypto = require('crypto');

const offerLetterSchema = new mongoose.Schema({
  application: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Application',
    required: [true, 'Application reference is required']
  },
  job: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Job',
    required: [true, 'Job reference is required']
  },
  
  // Candidate Information (cached for quick access)
  candidateInfo: {
    firstName: {
      type: String,
      required: true,
      trim: true
    },
    lastName: {
      type: String,
      required: true,
      trim: true
    },
    email: {
      type: String,
      required: true,
      lowercase: true,
      trim: true
    },
    phoneNumber: {
      type: String,
      required: true,
      trim: true
    }
  },
  
  // Job Information (cached for quick access)
  jobInfo: {
    title: {
      type: String,
      required: true,
      trim: true
    },
    department: {
      type: String,
      required: true,
      trim: true
    },
    location: {
      type: String,
      required: true,
      trim: true
    }
  },
  
  // Offer Details
  offerDetails: {
    // Salary Information
    salary: {
      basic: {
        type: Number,
        required: [true, 'Basic salary is required'],
        min: [0, 'Salary cannot be negative']
      },
      hra: {
        type: Number,
        default: 0
      },
      allowances: {
        type: Number,
        default: 0
      },
      ctc: {
        type: Number,
        required: [true, 'CTC is required'],
        min: [0, 'CTC cannot be negative']
      },
      currency: {
        type: String,
        default: 'INR'
      }
    },
    
    // Employment Details
    employmentType: {
      type: String,
      enum: ['Full-time', 'Part-time', 'Contract', 'Internship'],
      required: [true, 'Employment type is required']
    },
    workMode: {
      type: String,
      enum: ['On-site', 'Remote', 'Hybrid'],
      required: [true, 'Work mode is required']
    },
    joiningDate: {
      type: Date,
      required: [true, 'Joining date is required']
    },
    probationPeriod: {
      type: Number, // in months
      default: 6
    },
    noticePeriod: {
      type: Number, // in days
      default: 30
    },
    
    // Benefits
    benefits: [{
      type: String,
      trim: true
    }],
    
    // Terms and Conditions
    termsAndConditions: [{
      type: String,
      trim: true
    }],
    
    // Additional Information
    reportingManager: {
      name: String,
      designation: String,
      email: String
    },
    workingHours: {
      type: String,
      default: '9:00 AM - 6:00 PM'
    },
    workingDays: {
      type: String,
      default: 'Monday to Friday'
    }
  },
  
  // Offer Letter Document
  document: {
    fileName: String,
    filePath: String,
    mimeType: {
      type: String,
      default: 'application/pdf'
    },
    size: Number,
    generatedAt: Date
  },
  
  // Secure Access
  secureToken: {
    type: String,
    unique: true,
    required: true
  },
  secureLink: String,
  linkExpiresAt: {
    type: Date,
    required: true
  },
  
  // Offer Status
  status: {
    type: String,
    enum: [
      'Draft',
      'Generated',
      'Sent',
      'Viewed',
      'Accepted',
      'Rejected',
      'Expired',
      'Withdrawn'
    ],
    default: 'Draft'
  },
  
  // Timeline
  generatedAt: Date,
  sentAt: Date,
  viewedAt: Date,
  respondedAt: Date,
  
  // Response Information
  candidateResponse: {
    decision: {
      type: String,
      enum: ['Accept', 'Reject']
    },
    comments: {
      type: String,
      trim: true
    },
    respondedAt: Date,
    ipAddress: String,
    userAgent: String
  },
  
  // Email Tracking
  emailsSent: [{
    type: {
      type: String,
      enum: ['Offer Letter Sent', 'Offer Reminder', 'Offer Withdrawn']
    },
    sentTo: String,
    sentAt: {
      type: Date,
      default: Date.now
    },
    status: {
      type: String,
      enum: ['Sent', 'Failed'],
      default: 'Sent'
    }
  }],
  
  // System Information
  generatedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: [true, 'Generated by is required']
  },
  sentBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },
  
  // Validity
  validUntil: {
    type: Date,
    required: [true, 'Validity date is required']
  },
  
  // Notes
  internalNotes: {
    type: String,
    trim: true
  },
  
  // System fields
  isActive: {
    type: Boolean,
    default: true
  }
}, {
  timestamps: true
});

// Indexes for better query performance
offerLetterSchema.index({ application: 1 });
offerLetterSchema.index({ job: 1 });
offerLetterSchema.index({ secureToken: 1 });
offerLetterSchema.index({ status: 1 });
offerLetterSchema.index({ 'candidateInfo.email': 1 });
offerLetterSchema.index({ validUntil: 1 });
offerLetterSchema.index({ generatedBy: 1 });

// Pre-save middleware to generate secure token and link
offerLetterSchema.pre('save', function(next) {
  if (this.isNew || this.isModified('secureToken')) {
    // Generate secure token
    this.secureToken = crypto.randomBytes(32).toString('hex');
    
    // Generate secure link (will be updated with actual domain in production)
    const baseUrl = process.env.CLIENT_URL || 'http://localhost:3000';
    this.secureLink = `${baseUrl}/offer/${this.secureToken}`;
    
    // Set link expiration (30 days from now)
    this.linkExpiresAt = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000);
  }
  next();
});

// Virtual for candidate full name
offerLetterSchema.virtual('candidateFullName').get(function() {
  return `${this.candidateInfo.firstName} ${this.candidateInfo.lastName}`;
});

// Virtual for total compensation
offerLetterSchema.virtual('totalCompensation').get(function() {
  const salary = this.offerDetails.salary;
  return salary.basic + salary.hra + salary.allowances;
});

// Virtual for offer validity status
offerLetterSchema.virtual('isValid').get(function() {
  return new Date() <= this.validUntil && this.status !== 'Expired';
});

// Virtual for link validity status
offerLetterSchema.virtual('isLinkValid').get(function() {
  return new Date() <= this.linkExpiresAt;
});

// Method to generate offer letter
offerLetterSchema.methods.generate = function(generatedBy) {
  this.status = 'Generated';
  this.generatedAt = new Date();
  this.generatedBy = generatedBy;
  return this.save();
};

// Method to send offer letter
offerLetterSchema.methods.send = function(sentBy) {
  this.status = 'Sent';
  this.sentAt = new Date();
  this.sentBy = sentBy;
  return this.save();
};

// Method to mark as viewed
offerLetterSchema.methods.markViewed = function() {
  if (this.status === 'Sent') {
    this.status = 'Viewed';
    this.viewedAt = new Date();
    return this.save();
  }
  return Promise.resolve(this);
};

// Method to accept offer
offerLetterSchema.methods.accept = function(comments, metadata = {}) {
  this.status = 'Accepted';
  this.respondedAt = new Date();
  this.candidateResponse = {
    decision: 'Accept',
    comments: comments,
    respondedAt: new Date(),
    ipAddress: metadata.ipAddress,
    userAgent: metadata.userAgent
  };
  return this.save();
};

// Method to reject offer
offerLetterSchema.methods.reject = function(comments, metadata = {}) {
  this.status = 'Rejected';
  this.respondedAt = new Date();
  this.candidateResponse = {
    decision: 'Reject',
    comments: comments,
    respondedAt: new Date(),
    ipAddress: metadata.ipAddress,
    userAgent: metadata.userAgent
  };
  return this.save();
};

// Method to withdraw offer
offerLetterSchema.methods.withdraw = function() {
  this.status = 'Withdrawn';
  return this.save();
};

// Method to expire offer
offerLetterSchema.methods.expire = function() {
  this.status = 'Expired';
  return this.save();
};

// Method to extend validity
offerLetterSchema.methods.extendValidity = function(newValidityDate) {
  this.validUntil = newValidityDate;
  return this.save();
};

// Method to track email sent
offerLetterSchema.methods.trackEmailSent = function(emailType, sentTo, status = 'Sent') {
  this.emailsSent.push({
    type: emailType,
    sentTo: sentTo,
    status: status
  });
  return this.save();
};

// Static method to find by secure token
offerLetterSchema.statics.findByToken = function(token) {
  return this.findOne({ 
    secureToken: token, 
    isActive: true,
    linkExpiresAt: { $gte: new Date() }
  })
  .populate('application', 'firstName lastName email phoneNumber')
  .populate('job', 'title code department location');
};

// Static method to get offers by status
offerLetterSchema.statics.getByStatus = function(status) {
  return this.find({ status, isActive: true })
    .populate('application', 'firstName lastName email phoneNumber')
    .populate('job', 'title code department')
    .populate('generatedBy', 'firstName lastName')
    .sort({ createdAt: -1 });
};

// Static method to get expired offers
offerLetterSchema.statics.getExpired = function() {
  return this.find({
    validUntil: { $lt: new Date() },
    status: { $nin: ['Accepted', 'Rejected', 'Expired'] },
    isActive: true
  });
};

// Static method to auto-expire offers
offerLetterSchema.statics.autoExpireOffers = async function() {
  const expiredOffers = await this.getExpired();
  const updatePromises = expiredOffers.map(offer => offer.expire());
  return Promise.all(updatePromises);
};

// Transform output
offerLetterSchema.methods.toJSON = function() {
  const offerObject = this.toObject();
  // Remove sensitive information in API responses
  if (offerObject.secureToken) {
    delete offerObject.secureToken;
  }
  return offerObject;
};

// Transform output for public access (minimal information)
offerLetterSchema.methods.toPublicJSON = function() {
  return {
    _id: this._id,
    candidateInfo: this.candidateInfo,
    jobInfo: this.jobInfo,
    offerDetails: this.offerDetails,
    status: this.status,
    validUntil: this.validUntil,
    isValid: this.isValid,
    viewedAt: this.viewedAt,
    respondedAt: this.respondedAt,
    candidateResponse: this.candidateResponse
  };
};

module.exports = mongoose.model('OfferLetter', offerLetterSchema);
